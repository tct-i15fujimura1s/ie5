# OS2 :17 ZFS (pp. 187-199)

## MacOS のタイムマシン機能
* 最近、新たな機能が追加された
  * もともと、外付けのハードディスクにバックアップする機能だった
  * しかし、内蔵ハードディスクでも、定期的なバックアップを大量に取れるようになった

## ZFS
* 大きな主記憶、高速マルチプロセッサが前提（8GiB, 64bit CPU）
* COW (Copy On Write)
* 全ブロックにわたるチェックサムによる信頼性の確保
* 一瞬で **スナップショット** や **クローン** を作成 (COWの応用)
* ファイルサイズ等の制約がほぼない
* ストレージプールをボリュームの代わりに使用
* データ圧縮、重複除去

### 全ブロックに渡るチェックサム
* ブロックポインタがチェックサムをもつ
* メタデータだけでなく普通のデータにもチェックサムあり
* チェックサムの不整合→ミラーがあれば自動的にデータ修復

### ZFSのストレージプール
#### 従来の方式のボリューム
* ボリュームと対応するもの
  * ドライブ
  * パーティション
  * ディスクアレイ
* ファイルシステムの初期化以前にボリュームを決定
* あとでサイズの変更ができない

#### ストレージプール
* 一つのストレージプールが複数のファイルシステムに複数のデバイスを割り当てる
* ファイルシステムからの要求→ブロックをわりつける
* `malloc()` や `free()` に類似
* あとでデバイスを追加もできる

#### ストレージプールの構造

##### デバイス内部の構造
* VL<sub>n</sub>: Volume Label

| VL<sub>1</sub> (256KiB) |
| VL<sub>2</sub> (256KiB) |
| ブートコード (3.5MiB) |
| VL<sub>3</sub> (256KiB) |
| VL<sub>4</sub> (256KiB) |

##### ボリュームラベル

| デバイス情報など<br>名前/値ペア<br>(128KiB) |
| Uberblock[0] (1KiB) |
| Uberblock[1] (1KiB) |
| ... |
| Uberblock[127] (1KiB) |

* デバイスの4箇所に同じボリュームラベルを書く
* ボリュームラベルには128個のUberblockを格納できる
* Uberblockはトランザクショングループ番号を含んでいる
* Uberblockはトランザクショングループ番号を128で割った余りの位置に書く

#### Object-set layer
* ファイルシステムは Objset の dnode配列
* dnodeリストはUFSのi-nodeリストに相当
* master nodeはrootディレクトリのdnode番号などの情報

### ZFSのソフトウェア構成
* カーネル: システムコール → VNODE操作
* ZFS
  * ZPL (ZFS POSIX Layer): VNODE操作 → ZFSトランザクション
  * DMU (Data Management Unit): 複数トランザクション → **トランザクショングループ** → キャッシュに書き込み
  * SPA (Storage Pool Allocator): キャッシュ → デバイスに反映 (バースト)
    * キャッシュ上に散らばったデータをストレージプールの連続セクタに書き込む

### 重複除去
* 同じデータブロックを見つけると、1つの実体に集約してしまう

### ストレージプールの更新
* Uberblockを起点とする木構造でブロックが記録されている
* 変更: 新しいブロックを確保、内容を書き込み (COW)
* メタデータブロックもCOWで更新
* Uberblockを新しい領域に書き込む
  * トランザクショングループ番号が最新のUberblockが有効
  * 古い世代のブロックは解放され、再利用される

### ブロックポインタ

| **サイズ** | ブロックの大きさ |
| **チェックサム** (64ビット) | ブロックのチェックサム (最大3個) |
| **ブロックのアドレス** | ブロックのストレージプール内での格納位置 (最大３個) (デバイス, デバイス内アドレス) |
| **タイムスタンプ** | ブロックを作成したトランザクショングループの番号 (ブロック削除時にスナップショットと比較) |
| **その他** | チェックサム計算に使用するアルゴリズムの種類<br>データ圧縮に使用するアルゴリズムの種類<br>圧縮後のサイズなど |

### Dnode
* あらゆるオブジェクトを表現する512Bのデータ構造
  * ファイル
  * ディレクトリ
  * ファイルシステム
  * スナップショット
  * クローン など
* UFS の i-node に似ている
* 3つ以内のブロックポインタを格納できる
* 表現するオブジェクトに応じたデータ格納領域を持っている (ブロックポインタ領域と共用)

* 構造
  * 型: ファイル、ディレクトリなど
  * ブロックポインタ数
  * 間接レベル
  * データ格納領域
    * ブロックポインタ
    * ファイル属性情報

#### データブロック、直接参照と間接ブロック
* データの大きさ ≦ 128KiB → 直接参照
  * Dnodeはデータブロック (512B〜128KiB) への参照を持つ
  * 間接レベル=1
* データの大きさ ＞ 128KiB → 間接ブロックを使う
  * 間接ブロック (128KiB) はブロックポインタを最大 1024 個格納できる
    * 128Ki×1024 = 128MiB
  * データの大きさ ＞ 128MiB → 多重の間接ブロック (最大6レベル)
    * 間接レベル
      1. 128KiB
      2. 128MiB
      3. 128GiB
      4. 128TiB
      5. 128EiB
      6. 128ZiB

### MOS (Meta Object Set) layer
* Objset: dnodeの配列
  * ストレージプール全体の管理情報
  * ファイルシステムやスナップショット等の一覧
  * master node: ストレージプールのコンフィグ、プロパティなど
  * space map: ストレージプール内のブロックの割り付け

### スナップショット
* ファイルシステムは時間とともに変化する
* ある瞬間の状態を保存したものがスナップショット
* deadlist: 存在しなくなった解放できないブロックのリスト
  * 現在のスナップショットをとる前に削除された
  * 今は存在しないが、以前のスナップショットには存在する

#### スナップショットの作成
1. ファイルシステムを表すObjsetのコピーを作成
2. MOS layerのdnode配列に登録


* スナップショットは一瞬で作成できる
* 変更がないデータブロックは共用
* 内容が書き変わるとCOWで必要最小限のブロックをコピー

#### ブロックの解放
```
+ B#1
+ B#2

Snapshot#1: B#1, B#2
  deadlist:

- B#1
+ B#3

Snapshot#2: B#2, B#3
  deadlist: B#1

- B#2
+ B#4
- B#4

現在 (FileSystem):
  deadlist: B#2, B#3
```

* B#1はSnapshot#1で使用されているので解放できない
* B#2, B#3もスナップショットで使用されているので解放できない
* B#4は使用されていないので解放できる
* 解放できないブロックはdeadlistに格納される

##### Snapshot#2を削除すると
* B#1, B#2はSnapshot#1で使用されている → 解放できない
* B#3 はSnapshot#2が削除された → 解放できる
* B#2, B#2はFileSystemのdeadlistに格納される

----
試験範囲ここまで
----
